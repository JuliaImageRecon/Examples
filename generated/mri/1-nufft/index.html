<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NUFFT Overview · Examples</title><meta name="title" content="NUFFT Overview · Examples"/><meta property="og:title" content="NUFFT Overview · Examples"/><meta property="twitter:title" content="NUFFT Overview · Examples"/><meta name="description" content="Documentation for Examples."/><meta property="og:description" content="Documentation for Examples."/><meta property="twitter:description" content="Documentation for Examples."/><meta property="og:url" content="https://JuliaImageRecon.github.io/Examples/generated/mri/1-nufft/"/><meta property="twitter:url" content="https://JuliaImageRecon.github.io/Examples/generated/mri/1-nufft/"/><link rel="canonical" href="https://JuliaImageRecon.github.io/Examples/generated/mri/1-nufft/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Examples</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">MRI</span><ul><li class="is-active"><a class="tocitem" href>NUFFT Overview</a><ul class="internal"><li><a class="tocitem" href="#Radial-k-space-sampling"><span>Radial k-space sampling</span></a></li><li><a class="tocitem" href="#Radial-k-space-data-for-Shepp-Logan-phantom"><span>Radial k-space data for Shepp-Logan phantom</span></a></li><li><a class="tocitem" href="#Non-iterative-gridding-image-reconstruction"><span>Non-iterative gridding image reconstruction</span></a></li><li><a class="tocitem" href="#NUFFT-approach-to-gridding"><span>NUFFT approach to gridding</span></a></li><li><a class="tocitem" href="#Density-compensation"><span>Density compensation</span></a></li><li><a class="tocitem" href="#Iterative-MR-image-reconstruction-using-NUFFT"><span>Iterative MR image reconstruction using NUFFT</span></a></li><li><a class="tocitem" href="#Regularized-MR-image-reconstruction"><span>Regularized MR image reconstruction</span></a></li><li><a class="tocitem" href="#Edge-preserving-regularization-2"><span>Edge-preserving regularization</span></a></li><li><a class="tocitem" href="#Nonlinear-CG-algorithm"><span>Nonlinear CG algorithm</span></a></li></ul></li><li><a class="tocitem" href="../2-cs-wl-l1-2d/">Compressed Sensing 2D</a></li><li><a class="tocitem" href="../3-2d-t/">2D dynamic: temporal TV</a></li><li><a class="tocitem" href="../4-cs-sense-2d/">Compressed Sensing 2D pMRI </a></li><li><a class="tocitem" href="../5-l-plus-s/">L+S 2D dynamic recon</a></li><li><a class="tocitem" href="../99-varpro1/">Variable Projection: One exponential</a></li></ul></li><li><span class="tocitem">CT</span><ul><li><a class="tocitem" href="../../ct/1-fbp/">FBP Overview</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MRI</a></li><li class="is-active"><a href>NUFFT Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NUFFT Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/Examples" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/Examples/blob/main/docs/lit/mri/1-nufft.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="1-nufft"><a class="docs-heading-anchor" href="#1-nufft">NUFFT Overview</a><a id="1-nufft-1"></a><a class="docs-heading-anchor-permalink" href="#1-nufft" title="Permalink"></a></h1><p>This example illustrates how to use Nonuniform FFT (NUFFT) for image reconstruction in MRI using the Julia language.</p><p>This page comes from a single Julia file: <a href="https://github.com/JuliaImageRecon/Examples/blob/main/docs/lit/mri/1-nufft.jl"><code>1-nufft.jl</code></a>.</p><p>You can access the source code for such Julia documentation using the &#39;Edit on GitHub&#39; link in the top right. You can view the corresponding notebook in <a href="https://nbviewer.org/">nbviewer</a> here: <a href="https://nbviewer.org/github/JuliaImageRecon/Examples/tree/gh-pages/generated/mri/1-nufft.ipynb"><code>1-nufft.ipynb</code></a>, or open it in <a href="https://mybinder.org/">binder</a> here: <a href="https://mybinder.org/v2/gh/JuliaImageRecon/Examples/gh-pages?filepath=generated/mri/1-nufft.ipynb"><code>1-nufft.ipynb</code></a>.</p><p>Some MRI scans use non-Cartesian sampling patterns (like radial and spiral k-space trajectories, among others), often in the interest of acquisition speed.</p><p>Image reconstruction from fully sampled Cartesian k-space data typically uses simple inverse FFT operations, whereas non-Cartesian sampling requires more complicated methods.</p><p>The examples here illustrate both non-iterative (aka &quot;gridding&quot;) and iterative methods for non-Cartesian MRI reconstruction. For simplicity the examples consider the case of single-coil data and ignore the effects of B0 field inhomogeneity.</p><p>First we add the Julia packages that are need for these examples. Change <code>false</code> to <code>true</code> in the following code block if you are using any of the following packages for the first time.</p><pre><code class="language-julia hljs">if false
    import Pkg
    Pkg.add([
        &quot;ImagePhantoms&quot;
        &quot;Unitful&quot;
        &quot;Plots&quot;
        &quot;LaTeXStrings&quot;
        &quot;MIRTjim&quot;
        &quot;MIRT&quot;
        &quot;InteractiveUtils&quot;
    ])
end</code></pre><p>Now tell this Julia session to use the following packages. Run <code>Pkg.add()</code> in the preceding code block first, if needed.</p><pre><code class="language-julia hljs">using ImagePhantoms: shepp_logan, SheppLoganEmis, spectrum, phantom #, Gauss2
using LinearAlgebra: I
using Unitful: mm # Allows use of physical units (mm here)
using Plots; default(label=&quot;&quot;, markerstrokecolor=:auto)
using LaTeXStrings # for LaTeX in plot labels, e.g., L&quot;\alpha_n&quot;
using MIRTjim: jim, prompt # jiffy image display
using MIRT: Anufft, diffl_map, ncg
using InteractiveUtils: versioninfo</code></pre><p>The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each image is displayed.</p><pre><code class="language-julia hljs">isinteractive() &amp;&amp; jim(:prompt, true);</code></pre><h2 id="Radial-k-space-sampling"><a class="docs-heading-anchor" href="#Radial-k-space-sampling">Radial k-space sampling</a><a id="Radial-k-space-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-k-space-sampling" title="Permalink"></a></h2><p>We focus on radial sampling as a simple representative non-Cartesian case. Consider imaging a 256mm × 256mm field of FOV with the goal of reconstructing a 128 × 128 pixel image. The following radial and angular k-space sampling is reasonable.</p><pre><code class="language-julia hljs">N = 128
FOV = 256mm # physical units!
Δx = FOV / N # pixel size
kmax = 1 / 2Δx
kr = ((-N÷2):(N÷2)) / (N÷2) * kmax # radial sampling in k-space
Nr = length(kr) # N+1
Nϕ = 3N÷2 # theoretically should be about π/2 * N
kϕ = (0:Nϕ-1)/Nϕ * π # angular samples
νx = kr * cos.(kϕ)&#39; # N × Nϕ k-space sampling in cycles/mm
νy = kr * sin.(kϕ)&#39;
plot(νx, νy,
    xlabel=L&quot;\nu_x&quot;, ylabel=L&quot;\nu_y&quot;,
    aspect_ratio = 1,
    title = &quot;Radial k-space sampling&quot;,
)</code></pre><img src="f0510cda.svg" alt="Example block output"/><pre><code class="language-julia hljs">isinteractive() &amp;&amp; prompt();</code></pre><p>For the NUFFT routines considered here, the sampling arguments must be &quot;Ω&quot; values: digital frequencies have pseudo-units of radians / pixel.</p><pre><code class="language-julia hljs">Ωx = (2π * Δx) * νx # N × Nϕ grid of k-space sample locations
Ωy = (2π * Δx) * νy # in pseudo-units of radians / sample

scatter(Ωx, Ωy,
    xlabel=L&quot;\Omega_x&quot;, ylabel=L&quot;\Omega_y&quot;,
    xticks=((-1:1)*π, [&quot;-π&quot;, &quot;0&quot;, &quot;π&quot;]),
    yticks=((-1:1)*π, [&quot;-π&quot;, &quot;0&quot;, &quot;π&quot;]),
    xlims=(-π,π) .* 1.1,
    ylims=(-π,π) .* 1.1,
    aspect_ratio = 1, markersize = 0.5,
    title = &quot;Radial k-space sampling&quot;,
)</code></pre><img src="a0b5b6a7.svg" alt="Example block output"/><pre><code class="language-julia hljs">isinteractive() &amp;&amp; prompt();</code></pre><h2 id="Radial-k-space-data-for-Shepp-Logan-phantom"><a class="docs-heading-anchor" href="#Radial-k-space-data-for-Shepp-Logan-phantom">Radial k-space data for Shepp-Logan phantom</a><a id="Radial-k-space-data-for-Shepp-Logan-phantom-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-k-space-data-for-Shepp-Logan-phantom" title="Permalink"></a></h2><p>Get the ellipse parameters for a MRI-suitable version of the Shepp-Logan phantom and calculate (analytically) the radial k-space data. Then display in polar coordinates.</p><pre><code class="language-julia hljs">object = shepp_logan(SheppLoganEmis(); fovs=(FOV,FOV))
#object = [Gauss2(18mm, 0mm, 100mm, 70mm, 0, 1)] # useful for validating DCF
data = spectrum(object).(νx,νy)
data = data / oneunit(eltype(data)) # abandon units at this point
dscale = 10000
jimk = (args...; kwargs...) -&gt; jim(kr, kϕ, args...;
    xlabel = L&quot;k_r&quot;,
    ylabel = L&quot;k_{\phi}&quot;,
    xticks = (-1:1) .* maximum(abs, kr),
    yticks = (0,π),
    ylims = (0,π),
    aspect_ratio = :none,
    kwargs...
)
pk = jimk(abs.(data) / dscale; title=&quot;k-space data magnitude / $dscale&quot;)</code></pre><img src="f12f3954.svg" alt="Example block output"/><h2 id="Non-iterative-gridding-image-reconstruction"><a class="docs-heading-anchor" href="#Non-iterative-gridding-image-reconstruction">Non-iterative gridding image reconstruction</a><a id="Non-iterative-gridding-image-reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#Non-iterative-gridding-image-reconstruction" title="Permalink"></a></h2><p>It would be impossible for a radiologist to diagnose a patient from the k-space data in polar coordinates, so image reconstruction is needed.</p><p>The simplest approach is to (nearest-neighbor) interpolate the k-space data onto a Cartesian grid, and then reconstruction with an inverse FFT.</p><p>One way to do that interpolation is to use a <code>Histogram</code> method in Julia&#39;s statistics package.</p><pre><code class="language-julia hljs">using StatsBase: fit, Histogram, weights</code></pre><p>The following function is a work-around because <code>weights</code> in StatsBase is <a href="https://github.com/JuliaStats/StatsBase.jl/issues/745">limited to Real data</a>, so here we bin the real and imaginary k-space data separately, and handle the units.</p><pre><code class="language-julia hljs">function histogram(coord, vals::AbstractArray{&lt;:Number}, edges)
    u = oneunit(eltype(vals))
    wr = weights(real(vec(vals / u)))
    wi = weights(imag(vec(vals / u)))
    tmp1 = fit(Histogram, coord, wr, edges)
    tmp2 = fit(Histogram, coord, wi, edges)
    return u * complex.(tmp1.weights, tmp2.weights)
end

kx = N * Δx * νx # N × Nϕ k-space sampling in cycles/mm
ky = N * Δx * νy
bin = (-(N÷2):(N÷2)) .- 0.5 # (N+1,) histogram bin edges
gridded1 = histogram((vec(kx), vec(ky)), data, (bin,bin))

using FFTW: ifft, fftshift
tmp = fftshift(ifft(fftshift(gridded1)))
x = (-(N÷2):(N÷2-1)) * Δx
y = (-(N÷2):(N÷2-1)) * Δx
jim(x, y, tmp, title=&quot;Elementary gridding reconstruction&quot;)</code></pre><img src="544dc726.svg" alt="Example block output"/><p>That crummy gridding method does not work well. Here&#39;s what the phantom should look like:</p><pre><code class="language-julia hljs">ideal = phantom(x, y, object, 2)
clim = (0, 9)
p0 = jim(x, y, ideal, title=&quot;True Shepp-Logan phantom&quot;; clim)</code></pre><img src="5e47ff5a.svg" alt="Example block output"/><h2 id="NUFFT-approach-to-gridding"><a class="docs-heading-anchor" href="#NUFFT-approach-to-gridding">NUFFT approach to gridding</a><a id="NUFFT-approach-to-gridding-1"></a><a class="docs-heading-anchor-permalink" href="#NUFFT-approach-to-gridding" title="Permalink"></a></h2><p>Basic nearest-neighbor gridding does not provide acceptable image quality in MRI, so now we turn to using the NUFFT. For MRI purposes, the NUFFT is a function that maps Cartesian spaced image data into non-Cartesian k-space data. The <a href="https://github.com/tknopp/NFFT.jl">NFFT.jl</a> package has functions for computing the NUFFT and its adjoint. These are linear mappings (generalizations of matrices), so instead of calling those functions directly, here we use the NUFFT linear map object defined in MIRT that provides a non-Cartesian Fourier encoding &quot;matrix&quot;.</p><pre><code class="language-julia hljs">A = Anufft([vec(Ωx) vec(Ωy)], (N,N); n_shift = [N/2,N/2]) # todo: odim=(Nr,Nϕ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearMapAO: 24768 × 16384 odim=(24768,) idim=(128, 128) T=ComplexF64 Do=1 Di=2
prop = (name = &quot;nufft2&quot;, p = NFFTPlan with 24768 sampling points for an input array of size(128, 128) and an output array of size(24768,) with dims 1:2, w = [-3.141592653589793 -0.0; -3.0925052683774528 -0.0; … ; -3.0920912991575364 0.050598741254689016; -3.1411721134298785 0.05140189587777932], N = (128, 128), n_shift = [64.0, 64.0], nfft_m = 4, nfft_sigma = 2.0)
map = 24768×16384 LinearMaps.FunctionMap{ComplexF64,true}(#9, #13; issymmetric=false, ishermitian=false, isposdef=false)
</code></pre><p>Verify that the operator <code>A</code> works properly:</p><pre><code class="language-julia hljs">dx = FOV / N # pixel size
dx = dx / oneunit(dx) # abandon units for now
Ax_to_y = Ax -&gt; dx^2 * reshape(Ax, Nr, Nϕ) # trick
pj1 = jimk(abs.(Ax_to_y(A * ideal)) / dscale, &quot;|A*x|/$dscale&quot;)
pj2 = jimk(abs.(Ax_to_y(A * ideal) - data) / dscale, &quot;|A*x-y|/$dscale&quot;)
plot(pj1, pj2)</code></pre><img src="bc0e0d87.svg" alt="Example block output"/><p>This linear map is constructed to map a N × N image into <code>length(Ωx)</code> k-space samples. So its <a href="https://en.wikipedia.org/wiki/Adjoint">adjoint</a> goes the other direction. However, an adjoint is <em>not</em> an inverse!</p><pre><code class="language-julia hljs">gridded2 = A&#39; * vec(data)
jim(x, y, gridded2, title=&quot;NUFFT gridding without DCF&quot;)</code></pre><img src="728a7a95.svg" alt="Example block output"/><h2 id="Density-compensation"><a class="docs-heading-anchor" href="#Density-compensation">Density compensation</a><a id="Density-compensation-1"></a><a class="docs-heading-anchor-permalink" href="#Density-compensation" title="Permalink"></a></h2><p>To get a decent image with NUFFT-based gridding of non-Cartesian data, one must compensate for the k-space sampling density. See <a href="https://web.eecs.umich.edu/~fessler/book/c-four.pdf">this book chapter</a> for details.</p><p>Because this example uses radial sampling, we can borrow ideas from tomography, especially the <a href="https://en.wikipedia.org/wiki/Radon_transform#Radon_inversion_formula">ramp filter</a>, to define a reasonable density compensation function (DCF).</p><p>Here is a basic DCF version that uses the ramp filter in a simple way, corresponding to the areas of annular segments (Voronoi cells in polar coordinates). The <code>dcf .* data</code> line uses Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcast</a> feature to apply the 1D DCF to each radial spoke.</p><pre><code class="language-julia hljs">dν = 1/FOV # k-space radial sample spacing
dcf = pi / Nϕ * dν * abs.(kr) # (N+1) weights along k-space polar coordinate
dcf = dcf / oneunit(eltype(dcf)) # kludge: units not working with LinearMap now
gridded3 = A&#39; * vec(dcf .* data)
p3 = jim(x, y, gridded3, title=&quot;NUFFT gridding with simple ramp-filter DCF&quot;; clim)</code></pre><img src="c60c9af5.svg" alt="Example block output"/><p>The image is more reasonable than without any DCF, but we can do better (quantitatively) using the correction of <a href="https://doi.org/10.1002/mrm.1910360617">Lauzon&amp;Rutt, 1996</a> and <a href="https://doi.org/10.1002/mrm.1910400317">Joseph, 1998</a>.</p><pre><code class="language-julia hljs">dcf = pi / Nϕ * dν * abs.(kr) # see lauzon:96:eop, joseph:98:sei
dcf[kr .== 0/mm] .= pi * (dν/2)^2 / Nϕ # area of center disk
dcf = dcf / oneunit(eltype(dcf)) # kludge: units not working with LinearMap now
gridded4 = A&#39; * vec(dcf .* data)
p4 = jim(x, y, gridded4, title=&quot;NUFFT gridding with better ramp-filter DCF&quot;; clim)</code></pre><img src="7ad28664.svg" alt="Example block output"/><p>A profile helps illustrate the improvement.</p><pre><code class="language-julia hljs">pp = plot(x, real(gridded4[:,N÷2]), label=&quot;Modified ramp DCF&quot;)
plot!(x, real(gridded3[:,N÷2]), label=&quot;Basic ramp DCF&quot;)
plot!(x, real(ideal[:,N÷2]), label=&quot;Ideal&quot;, xlabel=L&quot;x&quot;, ylabel=&quot;middle profile&quot;)</code></pre><img src="9ad16f0f.svg" alt="Example block output"/><pre><code class="language-julia hljs">isinteractive() &amp;&amp; prompt();</code></pre><p>Finally we have made a NUFFT gridded image with DCF that has the appropriate range of values, but it still looks less than ideal. So next we try an iterative approach.</p><h2 id="Iterative-MR-image-reconstruction-using-NUFFT"><a class="docs-heading-anchor" href="#Iterative-MR-image-reconstruction-using-NUFFT">Iterative MR image reconstruction using NUFFT</a><a id="Iterative-MR-image-reconstruction-using-NUFFT-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-MR-image-reconstruction-using-NUFFT" title="Permalink"></a></h2><p>As an initial iterative approach, let&#39;s apply a few iterations of conjugate gradient (CG) to seek the minimizer of the least-squares cost function:</p><p class="math-container">\[\arg \min_{x} \frac{1}{2} \| A x - y \|_2^2.\]</p><p>CG is well-suited to minimizing quadratic cost functions, but we do not expect the image to be great quality because radial sampling omits the &quot;corners&quot; of k-space so the NUFFT operator <span>$A$</span> is badly conditioned.</p><p>There is a subtle point here about <code>dx</code> when converting the Fourier integral to a sum. Here <code>y</code> is <code>data/dx^2</code>.</p><pre><code class="language-julia hljs">gradf = u -&gt; u - vec(data/dx^2) # gradient of f(u) = 1/2 \| u - y \|^2
curvf = u -&gt; 1 # curvature of f(u)
x0 = gridded4 # initial guess: best gridding reconstruction
xls, _ = ncg([A], [gradf], [curvf], x0; niter = 20)
p5 = jim(x, y, xls, &quot;|LS-CG reconstruction|&quot;; clim)</code></pre><img src="17018005.svg" alt="Example block output"/><h2 id="Regularized-MR-image-reconstruction"><a class="docs-heading-anchor" href="#Regularized-MR-image-reconstruction">Regularized MR image reconstruction</a><a id="Regularized-MR-image-reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#Regularized-MR-image-reconstruction" title="Permalink"></a></h2><p>To improve the results, we include regularization. Here we would like to reconstruct an image by finding the minimizer of a regularized LS cost function such as the following:</p><p class="math-container">\[\arg \min_{x} \frac{1}{2} \| A x - y \|_2^2 + \beta R(x)
, \qquad
R(x) = 1&#39; \psi.(T x).\]</p><h3 id="Tikhonov-regularization"><a class="docs-heading-anchor" href="#Tikhonov-regularization">Tikhonov regularization</a><a id="Tikhonov-regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Tikhonov-regularization" title="Permalink"></a></h3><p>The simplest option is Tikhonov regularization, where <span>$R(x) = (β_0/2) \| x \|_2^2,$</span> corresponding to <span>$T = I$</span> and <span>$ψ(z) = (β_0/2) | z |^2$</span> above.</p><pre><code class="language-julia hljs">β₀ = 1e-0
xtik, _ = ncg([A, sqrt(β₀)*I], [gradf, x -&gt; β₀*x], [curvf, x -&gt; β₀], x0; niter = 80)
p6 = jim(x, y, xtik, &quot;|Tikhonov Regularized|&quot;; clim)</code></pre><img src="dad13930.svg" alt="Example block output"/><p>Comparing the error images with the same grayscale window, the regularized reconstruction has somewhat lower errors.</p><pre><code class="language-julia hljs">elim = (0, 1)
ecolor = :cividis
p5e = jim(x, y, abs.(xls - ideal), &quot;|LS-CG error|&quot;; clim=elim, color=ecolor)
p6e = jim(x, y, abs.(xtik - ideal), &quot;|Tik error|&quot;; clim=elim, color=ecolor)
plot(p5e, p6e; size=(800,300))</code></pre><img src="bb2f4ed9.svg" alt="Example block output"/><p>Errors in k-space</p><pre><code class="language-julia hljs">p5f = jimk(abs.(Ax_to_y(A * xls) - data) / dscale, &quot;|LS-CG kspace error|&quot;)
p6f = jimk(abs.(Ax_to_y(A * xtik) - data) / dscale, &quot;|Tik. kspace error|&quot;)
p56f = plot(p5f, p6f)</code></pre><img src="ceb1ad62.svg" alt="Example block output"/><h3 id="Edge-preserving-regularization"><a class="docs-heading-anchor" href="#Edge-preserving-regularization">Edge-preserving regularization</a><a id="Edge-preserving-regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-preserving-regularization" title="Permalink"></a></h3><p>Now consider edge-preserving regularization where <span>$T$</span> is a 2D finite-differencing operator and <span>$ψ$</span> is a potential function. This operator maps a <span>$N×N$</span> image into a <span>$N×N×2$</span> array with the horizontal and vertical finite differences.</p><pre><code class="language-julia hljs">T = diffl_map((N,N), [1,2] ; T = ComplexF32)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearMapAO: 32768 × 16384 odim=(128, 128, 2) idim=(128, 128) T=ComplexF32 Do=3 Di=2
prop = (name = &quot;diffl_map&quot;, N = (128, 128), dims = [1, 2])
map = 32768×16384 LinearMaps.FunctionMap{ComplexF32,true}(#9, #13; issymmetric=false, ishermitian=false, isposdef=false)
</code></pre><p>Applying this operator to the ideal image illustrated its action:</p><pre><code class="language-julia hljs">p7 = jim(x, y, T * ideal; nrow=1, size = (600, 300),
 title=&quot;Horizontal and vertical finite differences&quot;)</code></pre><img src="4ef0a589.svg" alt="Example block output"/><h2 id="Edge-preserving-regularization-2"><a class="docs-heading-anchor" href="#Edge-preserving-regularization-2">Edge-preserving regularization</a><a class="docs-heading-anchor-permalink" href="#Edge-preserving-regularization-2" title="Permalink"></a></h2><p>We use the Fair potential function: a rounded corner version of absolute value, an approximation to anisotropic total variation (TV).</p><pre><code class="language-julia hljs">β = 2^13 # regularization parameter
δ = 0.05 # edge-preserving parameter
wpot = z -&gt; 1 / (1 + abs(z)/δ) # weighting function</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#21 (generic function with 1 method)</code></pre><h2 id="Nonlinear-CG-algorithm"><a class="docs-heading-anchor" href="#Nonlinear-CG-algorithm">Nonlinear CG algorithm</a><a id="Nonlinear-CG-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-CG-algorithm" title="Permalink"></a></h2><p>We apply a (nonlinear) CG algorithm to seek the minimizer of the cost function. Nonlinear CG is well suited to convex problems that are locally quadratic like the regularized cost function considered here. See <a href="https://doi.org/10.1109/MSP.2019.2943645">this survey paper</a> for an overview of optimization methods for MRI.</p><pre><code class="language-julia hljs">B = [A, T] # see MIRT.ncg
gradf = [u -&gt; u - vec(data/dx^2), # data-term gradient, correct for pixel area
         u -&gt; β * (u .* wpot.(u))] # regularizer gradient
curvf = [u -&gt; 1, u -&gt; β] # curvature of quadratic majorizers
x0 = gridded4 # initial guess is best gridding reconstruction
xhat, _ = ncg(B, gradf, curvf, x0; niter = 90)
p8 = jim(x, y, xhat, &quot;Iterative reconstruction&quot;; clim)</code></pre><img src="e97935b0.svg" alt="Example block output"/><p>Compare the error images:</p><pre><code class="language-julia hljs">p8e = jim(x, y, abs.(xhat - ideal), &quot;|Reg. error|&quot;; clim=elim, color=ecolor)
p568e = plot(p5e, p6e, p8e; layout=(1,3), size=(1200,300))</code></pre><img src="9ac04a82.svg" alt="Example block output"/><p>Here is a comparison of the profiles.</p><pre><code class="language-julia hljs">plot!(pp, x, real(xls[:,N÷2]), label=&quot;LS-CG&quot;)
plot!(pp, x, real(xhat[:,N÷2]), label=&quot;Iterative edge-preserving&quot;, color=:black)</code></pre><img src="8f8f3129.svg" alt="Example block output"/><pre><code class="language-julia hljs">isinteractive() &amp;&amp; prompt();</code></pre><p>In this case, iterative image reconstruction provides the best looking image. One might argue this simulation was doomed to succeed, because the phantom is piece-wise constant, which is the best case for edge-preserving regularization. On the other hand, this was not an <a href="https://doi.org/10.1016/j.cam.2005.09.027">inverse crime</a> (<a href="https://arxiv.org/abs/2109.08237">see also here</a>) because the k-space data came from the analytical spectrum of ellipses, rather than from a discrete image.</p><h3 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h3><ul><li>The phantom used here was real-valued, which is unrealistic (although the reconstruction methods did not &quot;know&quot; it was real).</li><li>This simulation is for a single-coil scan whereas modern MRI scanners generally use multiple receive coils.</li><li>There was no statistical noise in this simulation.</li></ul><h3 id="Reproducibility"><a class="docs-heading-anchor" href="#Reproducibility">Reproducibility</a><a id="Reproducibility-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibility" title="Permalink"></a></h3><p>This page was generated with the following version of Julia:</p><pre><code class="language-julia hljs">using InteractiveUtils: versioninfo
io = IOBuffer(); versioninfo(io); split(String(take!(io)), &#39;\n&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{SubString{String}}:
 &quot;Julia Version 1.12.0&quot;
 &quot;Commit b907bd0600f (2025-10-07 15:42 UTC)&quot;
 &quot;Build Info:&quot;
 &quot;  Official https://julialang.org release&quot;
 &quot;Platform Info:&quot;
 &quot;  OS: Linux (x86_64-linux-gnu)&quot;
 &quot;  CPU: 4 × AMD EPYC 7763 64-Core Processor&quot;
 &quot;  WORD_SIZE: 64&quot;
 &quot;  LLVM: libLLVM-18.1.7 (ORCJIT, znver3)&quot;
 &quot;  GC: Built with stock GC&quot;
 &quot;Threads: 1 default, 1 interactive, 1 GC (on 4 virtual cores)&quot;
 &quot;&quot;</code></pre><p>And with the following package versions</p><pre><code class="language-julia hljs">import Pkg; Pkg.status()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Status `~/work/Examples/Examples/docs/Project.toml`
  [e30172f5] Documenter v1.14.1
  [940e8692] Examples v0.0.1 `~/work/Examples/Examples`
  [7a1cc6ca] FFTW v1.10.0
  [9ee76f2b] ImageGeoms v0.11.1
  [787d08f9] ImageMorphology v0.4.7
  [71a99df6] ImagePhantoms v0.8.1
  [b964fa9f] LaTeXStrings v1.4.0
  [7031d0ef] LazyGrids v1.1.0
  [599c1a8e] LinearMapsAA v0.12.0
  [98b081ad] Literate v2.20.1
  [23992714] MAT v0.10.7
  [7035ae7a] MIRT v0.18.2
  [170b2178] MIRTjim v0.25.0
  [efe261a4] NFFT v0.13.7
  [91a5bcdd] Plots v1.41.1
  [10745b16] Statistics v1.11.1
  [2913bbd2] StatsBase v0.34.6
  [1986cc42] Unitful v1.25.0
  [b77e0a4c] InteractiveUtils v1.11.0
  [37e2e46d] LinearAlgebra v1.12.0
  [44cfe95a] Pkg v1.12.0
  [9a3f8284] Random v1.11.0</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Home</a><a class="docs-footer-nextpage" href="../2-cs-wl-l1-2d/">Compressed Sensing 2D »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 15:43">Thursday 9 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
